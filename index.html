<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>학생 개인별 시간표 조회 HTML 페이지 생성기 2025</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <!-- 외부 CSS 파일 참조 -->
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div id="app-container">
        <div class="app-header">
            <h1>학생 개인별 시간표 조회 HTML 페이지 생성기</h1>
            <div class="help-link-wrapper">
                <a href="https://namgungyeon.tistory.com/131" target="_blank" class="help-link">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>
                    도움말
                </a>
            </div>
            <div class="app-credit">made by Namgung yeon (seolak high school)</div>
            <div class="app-version" id="app-version">Last updated : -</div>
        </div>

        <!-- 스텝 진행 인디케이터 -->
        <div class="step-indicator">
            <div class="step-item active" data-step="1">
                <div class="step-number">1</div>
                <div class="step-label">파일 업로드</div>
            </div>
            <div class="step-connector"></div>
            <div class="step-item" data-step="2">
                <div class="step-number">2</div>
                <div class="step-label">상세 정보</div>
            </div>
            <div class="step-connector"></div>
            <div class="step-item" data-step="3">
                <div class="step-number">3</div>
                <div class="step-label">HTML 생성</div>
            </div>
        </div>

        <div id="step1">
            <h2>1단계: 기본 파일 업로드</h2>
            <div class="upload-grid">
                <div id="upload-box-weekly" class="upload-box">
                    <p>주간시간표.xlsx</p>
                    <span class="file-name">파일을 선택하거나 끌어다 놓으세요</span>
                </div>
                <div id="upload-box-selection" class="upload-box">
                    <p>학생별선택과목파일.xlsx</p>
                    <span class="file-name">여러 개 업로드 가능</span>
                </div>
            </div>
            <input type="file" id="file-input-weekly" class="file-input" data-type="weekly" accept=".xlsx, .xls">
            <input type="file" id="file-input-selection" class="file-input" data-type="selection" accept=".xlsx, .xls" multiple>
            <button id="template-gen-button" disabled data-disabled-reason="두 개의 파일을 모두 업로드해주세요">선택과목 정보 템플릿 생성</button>
        </div>

        <div id="step2" style="display: none;">
            <div class="step2-header">
                <div class="step2-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/></svg>
                </div>
                <h2 class="step2-title">2단계: 선택과목 상세 정보 입력</h2>
                <span class="optional-badge">선택사항</span>
            </div>

            <div class="step2-description">
                <h4>이 단계에서 할 수 있는 작업</h4>
                <p>• <strong>교실 정보, 담당 교사</strong> 등 상세 정보를 추가할 수 있습니다</p>
                <p>• <strong>과목명을 축약형으로 변경</strong>하여 시간표가 더 깔끔해집니다</p>
                <p>• 건너뛰어도 기본 시간표는 정상적으로 생성됩니다</p>
            </div>

            <div class="process-steps">
                <div class="process-step">
                    <div class="process-step-number">1</div>
                    <div class="process-step-title">템플릿 다운로드</div>
                    <div class="process-step-desc">1단계에서 생성된<br>템플릿 파일 확인</div>
                </div>
                <div class="process-step">
                    <div class="process-step-number">2</div>
                    <div class="process-step-title">정보 수정</div>
                    <div class="process-step-desc">엑셀에서 교실, 교사,<br>축약명 등 입력</div>
                </div>
                <div class="process-step">
                    <div class="process-step-number">3</div>
                    <div class="process-step-title">파일 업로드</div>
                    <div class="process-step-desc">수정한 파일을<br>아래에 업로드</div>
                </div>
            </div>

            <div class="upload-section" id="upload-box-info">
                <div class="upload-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" width="36" height="36" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                </div>
                <div class="upload-title">수정한 선택과목정보.xlsx</div>
                <div class="upload-subtitle">템플릿을 수정했다면 여기에 드래그하거나 클릭하세요</div>
                <div class="file-status" id="file-status-info">대기 중...</div>
            </div>

            <input type="file" id="file-input-info" class="file-input" data-type="info" accept=".xlsx, .xls">

            <div class="template-actions">
                <button id="redownload-template-button" disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle; margin-right: 4px;"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                    템플릿 다시 다운로드
                </button>
            </div>

            <div class="skip-section">
                <h4>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="13 17 18 12 13 7"/><polyline points="6 17 11 12 6 7"/></svg>
                    건너뛰기
                </h4>
                <p>상세 정보 입력 없이 바로 3단계로 진행해도 시간표가 생성됩니다</p>
            </div>
        </div>

        <div id="step3" style="display: none;">
            <h2>3단계: 최종 HTML 파일 생성</h2>
             <div id="timetable-title-container">
                <label for="timetable-title">생성될 시간표 페이지 제목 설정:</label>
                <input type="text" id="timetable-title" placeholder="예: OOO고등학교 2025년 1학기 시간표 조회 시스템">
            </div>

            <div id="features-selection-container">
                <label class="section-label">시간표 조회 기능 선택:</label>
                <div class="features-grid">
                    <div class="feature-option">
                        <label>
                            <input type="checkbox" id="feature-student" checked>
                            <span class="feature-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg></span>
                            <div>
                                <div class="feature-title">학생별 조회</div>
                                <div class="feature-desc">개별 학생 시간표 검색</div>
                            </div>
                        </label>
                    </div>
                    <div class="feature-option">
                        <label>
                            <input type="checkbox" id="feature-class" checked>
                            <span class="feature-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M23 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></svg></span>
                            <div>
                                <div class="feature-title">반별 조회</div>
                                <div class="feature-desc">반 전체 시간표 조회</div>
                            </div>
                        </label>
                    </div>
                    <div class="feature-option">
                        <label>
                            <input type="checkbox" id="feature-classroom" checked>
                            <span class="feature-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg></span>
                            <div>
                                <div class="feature-title">교실별 조회</div>
                                <div class="feature-desc">교실 사용 현황 조회</div>
                            </div>
                        </label>
                    </div>
                    <div class="feature-option">
                        <label>
                            <input type="checkbox" id="feature-teacher" checked>
                            <span class="feature-icon"><svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"/><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"/></svg></span>
                            <div>
                                <div class="feature-title">선생님별 조회</div>
                                <div class="feature-desc">교사 시간표 조회</div>
                            </div>
                        </label>
                    </div>
                </div>
            </div>

            <div id="theme-selection-container">
                <label class="section-label">컬러 테마 선택:</label>
                <div class="theme-grid">
                    <div class="theme-option" data-theme="classic-blue">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #0F4C81 0%, #2E86AB 100%);"></div>
                        <div class="theme-name">Classic Blue</div>
                    </div>
                    <div class="theme-option" data-theme="living-coral">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #FF6F61 0%, #FF8A80 100%);"></div>
                        <div class="theme-name">Living Coral</div>
                    </div>
                    <div class="theme-option" data-theme="ultra-violet">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #6B5B95 0%, #8E7DBE 100%);"></div>
                        <div class="theme-name">Ultra Violet</div>
                    </div>
                    <div class="theme-option" data-theme="greenery">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #88B04B 0%, #A8CC8C 100%);"></div>
                        <div class="theme-name">Greenery</div>
                    </div>
                    <div class="theme-option" data-theme="marsala">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #955251 0%, #B87071 100%);"></div>
                        <div class="theme-name">Marsala</div>
                    </div>
                    <div class="theme-option selected" data-theme="serenity">
                        <div class="theme-preview" style="background: linear-gradient(135deg, #92A8D1 0%, #B8CAE6 100%);"></div>
                        <div class="theme-name">Serenity</div>
                    </div>
                </div>
            </div>

            <div class="upload-box" id="upload-box-icon">
                <div id="icon-preview-container">
                    <img id="icon-preview" alt="로고 미리보기">
                    <p>업로드된 로고</p>
                </div>
                <p>학교 로고/아이콘 업로드 (선택)</p>
                <span class="file-name">이미지 파일을 선택하거나 끌어다 놓으세요</span>
            </div>
            <input type="file" id="file-input-icon" class="file-input" data-type="icon" accept="image/*">
            <button id="generate-button" disabled data-disabled-reason="선택과목 정보 파일이 필요합니다">시간표 조회 시스템 HTML 생성</button>
        </div>

        <p id="status">1단계: 파일을 업로드해주세요.</p>
    </div>

    <!-- 토스트 알림 컨테이너 -->
    <div id="toast-container" aria-live="polite"></div>

    <!-- 외부 템플릿 파일 참조 -->
    <script src="student-timetable-template.js"></script>

    <script>
        // 템플릿 스크립트가 로드될 때까지 기다리기
        function waitForTemplate(callback, timeout = 5000) {
            const startTime = Date.now();

            function checkTemplate() {
                if (typeof window.StudentTimetableTemplate !== 'undefined') {
                    callback();
                } else if (Date.now() - startTime > timeout) {
                    showToast('템플릿 파일 로딩이 실패했습니다. 페이지를 새로고침하고 다시 시도해주세요.', 'error');
                    console.error('Template loading timeout');
                } else {
                    setTimeout(checkTemplate, 50);
                }
            }

            checkTemplate();
        }
    </script>

    <script>
        // 기존 로직 - CSS와 템플릿 부분은 외부 파일로 분리됨
        const UPLOAD_BOXES = {
            weekly: document.getElementById('upload-box-weekly'),
            selection: document.getElementById('upload-box-selection'),
            info: document.getElementById('upload-box-info'),
            icon: document.getElementById('upload-box-icon')
        };
        const FILE_INPUTS = {
            weekly: document.getElementById('file-input-weekly'),
            selection: document.getElementById('file-input-selection'),
            info: document.getElementById('file-input-info'),
            icon: document.getElementById('file-input-icon')
        };
        const TEMPLATE_GEN_BUTTON = document.getElementById('template-gen-button');
        const REDOWNLOAD_TEMPLATE_BUTTON = document.getElementById('redownload-template-button');
        const GENERATE_BUTTON = document.getElementById('generate-button');
        const STATUS_P = document.getElementById('status');
        const STEP2 = document.getElementById('step2');
        const STEP3 = document.getElementById('step3');
        const APP_VERSION = document.getElementById('app-version');

        let timetableData = {
            weekly: null,
            weeklyFormat: 'formatA',
            selection: [],
            info: null,
            iconBase64: null,
            selectedTheme: 'serenity'
        };

        // --- 토스트 알림 함수 ---
        function showToast(message, type = 'info', duration = 4000) {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transition = 'opacity 0.3s';
                setTimeout(() => toast.remove(), 300);
            }, duration);
        }

        // --- 상태 메시지 함수 ---
        function setStatus(message, type = '') {
            STATUS_P.textContent = message;
            STATUS_P.className = type ? `status-${type}` : '';
        }

        // --- 스텝 인디케이터 업데이트 ---
        function updateStepIndicator(currentStep) {
            document.querySelectorAll('.step-item').forEach((item) => {
                const stepNum = parseInt(item.dataset.step);
                item.classList.remove('active', 'completed');
                if (stepNum < currentStep) item.classList.add('completed');
                else if (stepNum === currentStep) item.classList.add('active');
            });
            document.querySelectorAll('.step-connector').forEach((connector, index) => {
                connector.classList.toggle('completed', index + 1 < currentStep);
            });
        }

        // --- 로딩 오버레이 ---
        function showLoading(message = '생성 중...') {
            const overlay = document.createElement('div');
            overlay.className = 'loading-overlay';
            overlay.id = 'loading-overlay';
            overlay.innerHTML = `<div class="spinner"></div><div class="loading-text">${message}</div>`;
            document.body.appendChild(overlay);
        }

        function hideLoading() {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) overlay.remove();
        }

        function updateAppVersionTimestamp() {
            if (!APP_VERSION) return;
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            APP_VERSION.textContent = `Last updated : ${yyyy}.${mm}.${dd} ${hh}:${min}`;
        }

        updateAppVersionTimestamp();

        // --- Event Listeners ---
        Object.keys(UPLOAD_BOXES).forEach(type => {
            UPLOAD_BOXES[type].addEventListener('click', () => FILE_INPUTS[type].click());
            FILE_INPUTS[type].addEventListener('change', (e) => handleFileSelect(e.target.files, type));

            UPLOAD_BOXES[type].addEventListener('dragover', e => {
                e.preventDefault();
                UPLOAD_BOXES[type].classList.add('dragover');
            });
            UPLOAD_BOXES[type].addEventListener('dragleave', e => {
                e.preventDefault();
                UPLOAD_BOXES[type].classList.remove('dragover');
            });
            UPLOAD_BOXES[type].addEventListener('drop', e => {
                e.preventDefault();
                UPLOAD_BOXES[type].classList.remove('dragover');
                handleFileSelect(e.dataTransfer.files, type);
            });
        });

        TEMPLATE_GEN_BUTTON.addEventListener('click', generateInfoTemplate);
        REDOWNLOAD_TEMPLATE_BUTTON.addEventListener('click', redownloadTemplate);
        GENERATE_BUTTON.addEventListener('click', generateAndDownloadHtml);

        // 테마 선택 이벤트 리스너
        document.addEventListener('click', (e) => {
            if (e.target.closest('.theme-option')) {
                const clickedOption = e.target.closest('.theme-option');
                const themeOptions = document.querySelectorAll('.theme-option');

                themeOptions.forEach(opt => opt.classList.remove('selected'));
                clickedOption.classList.add('selected');
                timetableData.selectedTheme = clickedOption.dataset.theme;
            }
        });

        // --- File Handling Functions ---
        function handleFileSelect(files, type) {
            if (!files || files.length === 0) return;

            Array.from(files).forEach(file => {
                const reader = new FileReader();

                if (type === 'icon') {
                     reader.onload = (e) => {
                        timetableData.iconBase64 = e.target.result;
                        updateUploadBoxUI(type, file.name);
                        showImagePreview(e.target.result);
                     };
                     reader.readAsDataURL(file);
                     return;
                }

                reader.onload = (e) => {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];

                    if (type === 'weekly') {
                        const previewData = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: 'A1:Z10' });
                        timetableData.weeklyFormat = detectTimetableFormat(previewData);
                        const formatName = timetableData.weeklyFormat === 'formatB' ? '압핀 양식' : '컴시간 양식';

                        const headerRow = timetableData.weeklyFormat === 'formatB' ? 0 : 0;
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, range: headerRow, defval: "" });

                        console.log('[UPLOAD] 엑셀 파일 처음 5행:');
                        for (let i = 0; i < Math.min(5, jsonData.length); i++) {
                            console.log(`${i+1}행:`, jsonData[i]);
                        }

                        timetableData.weekly = jsonData;
                        updateUploadBoxUI('weekly', `${file.name} (${formatName} 감지)`);

                    } else if (type === 'selection') {
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                        timetableData.selection.push({ name: file.name, data: jsonData });
                        const fileNames = timetableData.selection.map(f => f.name).join(', ');
                        updateUploadBoxUI('selection', fileNames);

                    } else { // info
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                        timetableData[type] = jsonData;
                        updateUploadBoxUI(type, file.name);
                    }

                    checkFilesForStep1();
                    if(type === 'info') checkFilesForStep3();
                };
                reader.onerror = (error) => {
                    console.error('[ERROR] 파일 읽기 오류:', error);
                    setStatus(`"${file.name}" 파일 읽기 오류: ${error.message || '파일 형식을 확인해주세요.'}`, 'error');
                    updateUploadBoxUI(type, '오류', false);
                };
                reader.readAsArrayBuffer(file);
            });
        }

        function updateUploadBoxUI(type, text, isSuccess = true) {
            if (type === 'info') {
                const box = UPLOAD_BOXES[type];
                const fileStatus = document.getElementById('file-status-info');
                const uploadTitle = box.querySelector('.upload-title');
                const uploadSubtitle = box.querySelector('.upload-subtitle');

                if (isSuccess) {
                    box.classList.add('uploaded');
                    fileStatus.textContent = `${text} (업로드 완료)`;
                    uploadTitle.textContent = '업로드 완료!';
                    uploadSubtitle.textContent = '파일이 성공적으로 업로드되었습니다';
                } else {
                    box.classList.remove('uploaded');
                    fileStatus.textContent = '오류 발생';
                    uploadTitle.textContent = '업로드 오류';
                    uploadSubtitle.textContent = '파일을 다시 확인해주세요';
                }
            } else {
                const box = UPLOAD_BOXES[type];
                box.querySelector('.file-name').textContent = text;
                if(isSuccess) box.classList.add('uploaded');
                else box.classList.remove('uploaded');
            }
        }

        function showImagePreview(imageSrc) {
            const previewContainer = document.getElementById('icon-preview-container');
            const previewImg = document.getElementById('icon-preview');
            previewImg.src = imageSrc;
            previewContainer.style.display = 'block';
        }

        function redownloadTemplate() {
            if (!timetableData.info || timetableData.info.length === 0) {
                showToast('먼저 템플릿을 생성해주세요.', 'warning');
                return;
            }

            const worksheet = XLSX.utils.aoa_to_sheet(timetableData.info);
            const colWidths = timetableData.info[0].map((_, i) => ({
                wch: timetableData.info.reduce((w, r) => Math.max(w, String(r[i] || '').length), 10)
            }));
            worksheet['!cols'] = colWidths;
            const workbook = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(workbook, worksheet, "선택과목정보_템플릿");
            const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/octet-stream' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = '선택과목정보_템플릿.xlsx';
            document.body.appendChild(link);
            link.click();
            URL.revokeObjectURL(link.href);
            document.body.removeChild(link);

            setStatus('템플릿이 다시 다운로드되었습니다!', 'success');
        }

        function checkFilesForStep1() {
            if (timetableData.weekly && timetableData.selection.length > 0) {
                TEMPLATE_GEN_BUTTON.disabled = false;
                TEMPLATE_GEN_BUTTON.removeAttribute('data-disabled-reason');
                setStatus('1단계 완료! 템플릿 생성 버튼을 눌러주세요.', 'success');
            }
        }

        function checkFilesForStep3() {
            if (timetableData.info) {
                 GENERATE_BUTTON.disabled = false;
                 GENERATE_BUTTON.removeAttribute('data-disabled-reason');
                 setStatus('모든 파일 준비 완료! 최종 HTML을 생성하세요.', 'success');
            }
        }

        function detectTimetableFormat(data) {
            if (data.length >= 4) {
                const row3 = data[2] || [];
                if (row3.includes('월') || row3.includes('화') || row3.includes('수')) {
                    return 'formatB';
                }
            }
            return 'formatA';
        }

        // --- Template Generation Logic ---
        function generateInfoTemplate() {
            try {
                const allSelections = {};
                timetableData.selection.forEach(file => {
                    if (!file.data || file.data.length < 2) {
                        console.warn(`[WARN] 파일 ${file.name}에 유효한 데이터가 없습니다.`);
                        return;
                    }
                    const header = file.data[0];
                    const rows = file.data.slice(1);
                    rows.forEach(row => {
                        if (!row || row.length < 6) return;
                        const grade = row[1];
                        if (!grade) return;
                        for (let i = 5; i < Math.min(header.length, row.length); i++) {
                            const subjectName = header[i];
                            const selectionGroup = row[i];
                            if (subjectName && selectionGroup) {
                                const key = `${grade}_${subjectName}_${selectionGroup}`;
                                allSelections[key] = { grade, subjectName, selectionGroup };
                            }
                        }
                    });
                });
                let selectionList = Object.values(allSelections);

                selectionList.sort((a, b) => {
                    if (a.grade !== b.grade) return String(a.grade).localeCompare(String(b.grade));
                    return a.selectionGroup.localeCompare(b.selectionGroup, undefined, {numeric: true});
                });

                const groupTimings = {};
                const weeklyRaw = timetableData.weekly;

                if (timetableData.weeklyFormat === 'formatB') {
                    const dayHeaders = weeklyRaw[2] || [];
                    const periodHeaders = weeklyRaw[3] || [];
                    const columnMap = {};
                    let currentDay = '';
                    for (let i = 1; i < dayHeaders.length; i++) {
                        if (dayHeaders[i] && ['월', '화', '수', '목', '금'].includes(dayHeaders[i])) {
                            currentDay = dayHeaders[i];
                        }
                        if (currentDay && periodHeaders[i]) {
                            columnMap[i] = { day: currentDay, period: parseInt(periodHeaders[i], 10) };
                        }
                    }
                    for (let i = 4; i < weeklyRaw.length; i++) {
                        const subjectRow = weeklyRaw[i];
                        const locationRow = weeklyRaw[i + 1];
                        if (!locationRow || (locationRow[0] !== '' && locationRow[0] !== null)) continue;

                        for (let col = 1; col < subjectRow.length; col++) {
                            const subject = subjectRow[col];
                            const location = locationRow[col];
                            const timeInfo = columnMap[col];
                            if (subject && location && timeInfo) {
                                const subjectMatch = String(subject).match(/^([A-Z])\s?/);
                                const locationMatch = String(location).match(/^(\d)-(\d+)/);

                                if (subjectMatch && locationMatch) {
                                    const grade = locationMatch[1];
                                    const group = subjectMatch[1];
                                    const key = `${grade}_${group}`;

                                    if (!groupTimings[key]) groupTimings[key] = [];

                                    if (!groupTimings[key].some(t => t.day === timeInfo.day && t.period === timeInfo.period)) {
                                         groupTimings[key].push(timeInfo);
                                    }
                                }
                            }
                        }
                        i++;
                    }
                } else { // formatA (컴시간 양식)
                    const totalCells = weeklyRaw[0].length - 1;
                    const periodStructure = calculatePeriodStructure(totalCells, weeklyRaw);
                    console.log('[TEMPLATE] 교시 구조:', periodStructure);
                    const daysInOrder = ['월', '화', '수', '목', '금'];

                    weeklyRaw.forEach(row => {
                        const scheduleData = row.slice(1);
                        let currentIndex = 0;
                        for (let i = 0; i < daysInOrder.length; i++) {
                            const day = daysInOrder[i];
                            const count = periodStructure.periodCounts[i] || 0;
                            const daySchedule = scheduleData.slice(currentIndex, currentIndex + count);

                            daySchedule.forEach((cell, periodIndex) => {
                                if (cell) {
                                    const cellStr = String(cell);
                                    const match = cellStr.match(/^(\d)\d{2}\s+([A-Za-z0-9]+)_/);
                                    if (match) {
                                        const grade = match[1];
                                        const group = match[2];
                                        const key = `${grade}_${group}`;
                                        if (!groupTimings[key]) groupTimings[key] = [];
                                        groupTimings[key].push({ day, period: periodIndex + 1 });
                                    }
                                }
                            });
                            currentIndex += count;
                        }
                    });
                }

                const findTimeInfo = (grade, group, timings) => {
                    let allTimes = [];
                    const checkAndAddTime = (key) => { if (timings[key]) allTimes.push(...timings[key]); };

                    checkAndAddTime(`${grade}_${group}`);
                    checkAndAddTime(`${grade}_${group.toUpperCase()}`);
                    if (group.length > 0) checkAndAddTime(`${grade}_${group.charAt(0).toUpperCase()}`);

                    return allTimes.filter((time, index, self) => index === self.findIndex((t) => t.day === time.day && t.period === time.period));
                };

                const templateRows = [['학년', '선택반명', '교과명', '수업교실', '수업교사명', '수업시간', '축약-교과명']];
                selectionList.forEach(sel => {
                    const { grade, subjectName, selectionGroup } = sel;
                    const timeInfoArray = findTimeInfo(grade, selectionGroup, groupTimings);
                    const timeString = timeInfoArray.map(t => `${t.day}${t.period}`).join(',');
                    templateRows.push([grade, selectionGroup, subjectName, '', '', timeString, '']);
                });

                timetableData.info = templateRows;

                const worksheet = XLSX.utils.aoa_to_sheet(templateRows);
                const colWidths = templateRows[0].map((_, i) => ({ wch: templateRows.reduce((w, r) => Math.max(w, String(r[i] || '').length), 10) }));
                worksheet['!cols'] = colWidths;
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, "선택과목정보_템플릿");
                const wbout = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
                const blob = new Blob([wbout], { type: 'application/octet-stream' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = '선택과목정보_템플릿.xlsx';
                document.body.appendChild(link);
                link.click();
                URL.revokeObjectURL(link.href);
                document.body.removeChild(link);

                setStatus('기본 템플릿 생성 완료! 수정이 필요하면 다운로드된 파일을 2단계에 업로드하고, 아니면 바로 3단계로 진행하세요.', 'success');
                STEP2.style.display = 'block';
                STEP3.style.display = 'block';
                REDOWNLOAD_TEMPLATE_BUTTON.disabled = false;
                updateStepIndicator(2);
                checkFilesForStep3();
            } catch (error) {
                setStatus('템플릿 생성 중 오류가 발생했습니다. 콘솔을 확인해주세요.', 'error');
                console.error("[ERROR] Template generation:", error);
            }
        }

        // --- Final HTML Generation Logic ---
        function calculatePeriodStructure(totalCells, weeklyRaw = null) {
            if (weeklyRaw && weeklyRaw.length >= 3) {
                try {
                    const result = parseDynamicPeriodStructure(weeklyRaw, totalCells);
                    if (result) {
                        console.log('[PARSE] 동적 파싱 성공:', result);
                        return result;
                    }
                } catch (error) {
                    console.warn('[PARSE] 동적 교시 구조 파싱 중 오류:', error);
                }
            }

            const commonPatterns = [
                [7, 7, 7, 6, 6], [7, 7, 6, 7, 6], [7, 7, 7, 7, 7], [6, 6, 6, 6, 6], [8, 8, 8, 7, 7],
                [7, 7, 6, 6, 6], [7, 6, 6, 6, 6], [8, 8, 7, 7, 7], [8, 7, 7, 7, 7], [7, 7, 4, 7, 5]
            ];
            for (const pattern of commonPatterns) {
                if (pattern.reduce((a, b) => a + b, 0) === totalCells) {
                    console.log(`[PARSE] 패턴 매칭: [${pattern.join(', ')}], 총 셀 수: ${totalCells}`);
                    return { periodCounts: pattern, maxPeriods: Math.max(...pattern) };
                }
            }
            console.log(`[PARSE] 기본 패턴 사용: [7, 7, 7, 6, 6], 총 셀 수: ${totalCells}`);
            return { periodCounts: [7, 7, 7, 6, 6], maxPeriods: 7 };
        }

        function parseDynamicPeriodStructure(weeklyRaw, totalCells) {
            const daysInOrder = ['월', '화', '수', '목', '금'];
            const row2 = weeklyRaw[1] || [];
            const row3 = weeklyRaw[2] || [];

            console.log('[PARSE] 2행 (요일):', row2);
            console.log('[PARSE] 3행 (교시):', row3);

            const dayPositions = [];
            for (let col = 0; col < row2.length; col++) {
                const cellValue = row2[col];
                if (cellValue && daysInOrder.includes(String(cellValue).trim())) {
                    dayPositions.push({
                        day: String(cellValue).trim(),
                        startCol: col
                    });
                }
            }

            console.log('[PARSE] 요일 위치들:', dayPositions);

            const dayPeriodMap = {};

            for (let i = 0; i < dayPositions.length; i++) {
                const currentDay = dayPositions[i];
                const nextDay = dayPositions[i + 1];
                const endCol = nextDay ? nextDay.startCol - 1 : row3.length - 1;

                let maxPeriod = 0;
                const periodsFound = [];
                for (let col = currentDay.startCol; col <= endCol; col++) {
                    if (col < row3.length && row3[col] !== null && row3[col] !== undefined) {
                        const cellValue = String(row3[col]).trim();
                        if (cellValue !== '' && cellValue !== 'null' && cellValue !== 'undefined') {
                            const periodNum = parseFloat(cellValue);
                            if (!isNaN(periodNum) && periodNum >= 1) {
                                periodsFound.push(periodNum);
                                maxPeriod = Math.max(maxPeriod, periodNum);
                            }
                        }
                    }
                }
                console.log(`[PARSE] ${currentDay.day}요일 범위 ${currentDay.startCol}~${endCol}: 교시 ${periodsFound}, 최대: ${maxPeriod}`);

                if (maxPeriod > 0) {
                    dayPeriodMap[currentDay.day] = maxPeriod;
                }
            }

            const periodCounts = [];
            for (const day of daysInOrder) {
                periodCounts.push(dayPeriodMap[day] || 0);
            }

            const totalCalculated = periodCounts.reduce((a, b) => a + b, 0);
            console.log('[PARSE] 동적 파싱 결과:', periodCounts, '총합:', totalCalculated);

            if (totalCalculated > 0) {
                return {
                    periodCounts: periodCounts,
                    maxPeriods: Math.max(...periodCounts)
                };
            }

            return null;
        }

        function parseSubjectAndTeacher(rawString) {
            if (!rawString) return { subject: '', teacher: '' };

            const patterns = [
                /^(.+?)\((.+?)\)$/,
                /^(.+?)\s+([가-힣]{2,4})$/,
                /^(.+)$/
            ];

            for (const pattern of patterns) {
                const match = rawString.match(pattern);
                if (match) {
                    if (match.length === 3) {
                        let teacherName = match[2].trim();
                        teacherName = teacherName.replace(/\(\d+\)$/, '');
                        return { subject: match[1].trim(), teacher: teacherName };
                    } else {
                        return { subject: match[1].trim(), teacher: '' };
                    }
                }
            }

            return { subject: rawString.trim(), teacher: '' };
        }

        function cleanTeacherName(teacherName) {
            if (!teacherName) return '';
            return teacherName.replace(/\(\d+\)$/, '').trim();
        }

        function processAllData() {
            const weeklyRaw = timetableData.weekly;
            const fixedSchedules = {};
            const daysInOrder = ['월', '화', '수', '목', '금'];
            let periodStructure, maxPeriods;

            if (timetableData.weeklyFormat === 'formatB') {
                const dayHeaders = weeklyRaw[2] || [];
                const periodHeaders = weeklyRaw[3] || [];

                let dayRanges = {};
                let currentDay = '';
                for (let i = 1; i < dayHeaders.length; i++) {
                    if (dayHeaders[i] && ['월', '화', '수', '목', '금'].includes(dayHeaders[i])) {
                        currentDay = dayHeaders[i];
                        if (!dayRanges[currentDay]) dayRanges[currentDay] = [];
                    }
                    if (currentDay && periodHeaders[i]) {
                        dayRanges[currentDay].push({ period: periodHeaders[i], column: i });
                    }
                }

                const periodCounts = daysInOrder.map(day => dayRanges[day] ? dayRanges[day].length : 0);
                maxPeriods = Math.max(...periodCounts, 0);
                periodStructure = { periodCounts, maxPeriods };

                const teacherInfo = {};

                for (let i = 0; i < weeklyRaw.length; i++) {
                    const row = weeklyRaw[i];
                    if (!row || !row[0]) continue;

                    const classMatch = String(row[0]).match(/^(\d)-(\d+)$/);
                    if (classMatch) {
                        const homeroom = `${classMatch[1]}-${classMatch[2]}`;
                        teacherInfo[homeroom] = {};

                        daysInOrder.forEach(day => {
                            if (!dayRanges[day]) return;
                            teacherInfo[homeroom][day] = {};

                            dayRanges[day].forEach(periodInfo => {
                                const cellValue = row[periodInfo.column];
                                if (cellValue) {
                                    const periodIndex = parseInt(periodInfo.period, 10);
                                    const teacherMatch = String(cellValue).match(/([가-힣]{2,4})$/);
                                    if (teacherMatch) {
                                        teacherInfo[homeroom][day][periodIndex] = teacherMatch[1];
                                    }
                                }
                            });
                        });
                    }
                }

                for (let i = 4; i < weeklyRaw.length; i += 2) {
                    const subjectRow = weeklyRaw[i];
                    const locationRow = weeklyRaw[i + 1];

                    if (!subjectRow || !locationRow) continue;
                    if (locationRow[0] !== '' && locationRow[0] !== null && locationRow[0] !== undefined) continue;

                    daysInOrder.forEach(day => {
                        if (!dayRanges[day]) return;
                        dayRanges[day].forEach(periodInfo => {
                            const subject = subjectRow[periodInfo.column];
                            const location = locationRow[periodInfo.column];

                            if (subject && location) {
                                const periodIndex = parseInt(periodInfo.period, 10);

                                if (/^\d+-\d+$/.test(String(location).trim())) {
                                    const homeroom = String(location).trim();
                                    if (!fixedSchedules[homeroom]) {
                                        fixedSchedules[homeroom] = { schedule: {} };
                                        daysInOrder.forEach(d => {
                                            fixedSchedules[homeroom].schedule[d] = Array(maxPeriods).fill(null);
                                        });
                                    }

                                    if (periodIndex >= 1) {
                                        const arrayIndex = periodIndex - 1;
                                        const teacherName = teacherInfo[homeroom] &&
                                                           teacherInfo[homeroom][day] &&
                                                           teacherInfo[homeroom][day][periodIndex] || '';

                                        const subjectName = String(subject).trim();

                                        fixedSchedules[homeroom].schedule[day][arrayIndex] = {
                                            subject: subjectName,
                                            teacher: teacherName,
                                            location: ''
                                        };
                                    }
                                }
                            }
                        });
                    });
                }

                for (let i = 4; i < weeklyRaw.length; i += 2) {
                    const subjectRow = weeklyRaw[i];
                    const locationRow = weeklyRaw[i + 1];

                    if (!subjectRow || !locationRow) continue;
                    if (locationRow[0] !== '' && locationRow[0] !== null && locationRow[0] !== undefined) continue;

                    daysInOrder.forEach(day => {
                        if (!dayRanges[day]) return;
                        dayRanges[day].forEach(periodInfo => {
                            const subject = subjectRow[periodInfo.column];
                            const location = locationRow[periodInfo.column];

                            if (subject && location && !/^\d+-\d+$/.test(String(location).trim())) {
                                const classroomName = String(location).trim();
                                const subjectName = String(subject).trim();
                                const periodIndex = parseInt(periodInfo.period, 10);

                                Object.keys(fixedSchedules).forEach(homeroom => {
                                    const arrayIndex = periodIndex - 1;
                                    if (arrayIndex >= 0 && fixedSchedules[homeroom].schedule[day][arrayIndex]) {
                                        const schedule = fixedSchedules[homeroom].schedule[day][arrayIndex];
                                        if (schedule && schedule.subject === subjectName) {
                                            schedule.location = classroomName;
                                        }
                                    }
                                });
                            }
                        });
                    });
                }

            } else { // formatA (컴시간 양식)
                const totalCells = weeklyRaw.length > 0 && weeklyRaw[0].length > 1 ? weeklyRaw[0].length - 1 : 33;
                periodStructure = calculatePeriodStructure(totalCells, weeklyRaw);
                maxPeriods = periodStructure.maxPeriods;

                weeklyRaw.forEach(row => {
                    const teacherName = cleanTeacherName(row[0] ? String(row[0]).trim() : '');
                    const scheduleData = row.slice(1);

                    for (let i = 0; i < daysInOrder.length; i++) {
                        const day = daysInOrder[i];
                        const count = periodStructure.periodCounts[i] || 0;

                        let startIndex = 0;
                        for (let j = 0; j < i; j++) {
                            startIndex += periodStructure.periodCounts[j] || 0;
                        }

                        const daySchedule = scheduleData.slice(startIndex, startIndex + count);

                        daySchedule.forEach((cell, periodIndex) => {
                            if (cell) {
                                const cellStr = String(cell);
                                if (/^\d{3}\s/.test(cellStr)) {
                                    const classIdentifier = cellStr.substring(0, 3);
                                    const grade = classIdentifier.charAt(0);
                                    const classNum = classIdentifier.substring(1).replace(/^0/, '');
                                    const homeroom = `${grade}-${classNum}`;

                                    if (!fixedSchedules[homeroom]) {
                                        fixedSchedules[homeroom] = { schedule: {} };
                                        daysInOrder.forEach(d => {
                                            fixedSchedules[homeroom].schedule[d] = Array(maxPeriods).fill(null);
                                        });
                                    }

                                    const remainingText = cellStr.substring(4).trim();

                                    let classroom = '';
                                    let subjectAndTeacher = remainingText;

                                    const classroomPatterns = [
                                        /^(\d+\w*)\s+(.+)$/,
                                        /^(\w+실\d*)\s+(.+)$/,
                                        /^(\w+교실\d*)\s+(.+)$/,
                                        /^([A-Za-z]\d*)\s+(.+)$/,
                                        /^(\w+관\d*)\s+(.+)$/
                                    ];

                                    for (const pattern of classroomPatterns) {
                                        const match = remainingText.match(pattern);
                                        if (match) {
                                            classroom = match[1];
                                            subjectAndTeacher = match[2];
                                            break;
                                        }
                                    }

                                    const parsedInfo = parseSubjectAndTeacher(subjectAndTeacher);
                                    const finalTeacherName = parsedInfo.teacher || teacherName;

                                    fixedSchedules[homeroom].schedule[day][periodIndex] = {
                                        subject: parsedInfo.subject,
                                        teacher: finalTeacherName,
                                        location: classroom
                                    };
                                }
                            }
                        });
                    }
                });
            }

            // 선택과목 정보 처리 (같은 키에 여러 교사가 있을 수 있으므로 배열로 저장)
            const electiveInfoMap = {};
            const electiveRows = timetableData.info.slice(1);
            electiveRows.forEach(row => {
                if (!row[0] || !row[1] || !row[2]) return;
                const key = `${row[0]}_${row[2]}_${row[1]}`;
                if (!electiveInfoMap[key]) {
                    electiveInfoMap[key] = [];
                }
                electiveInfoMap[key].push({
                    subject: row[6] || row[2],
                    location: row[3],
                    teacher: row[4],
                    times: row[5]
                });
            });

            // 학생별 시간표 생성
            const students = [];
            timetableData.selection.forEach(file => {
                const selectionHeader = file.data[0];
                const selectionRows = file.data.slice(1);
                selectionRows.forEach(row => {
                    if (!row[1] || !row[2] || !row[4]) return;

                    const grade = row[1];
                    const classNum = row[2];
                    const student = {
                        name: row[4],
                        studentId: row[3] || '',
                        homeroom: `${grade}-${classNum}`,
                        number: row[3] || '',
                        schedule: {},
                        maxPeriods: periodStructure.maxPeriods,
                        periodCounts: periodStructure.periodCounts
                    };

                    daysInOrder.forEach(d => {
                        student.schedule[d] = Array(student.maxPeriods).fill('');
                    });

                    // 선택과목 배치 (같은 키에 여러 교사가 있을 수 있으므로 배열 순회)
                    for (let i = 5; i < selectionHeader.length; i++) {
                        const subjectNameFromHeader = selectionHeader[i];
                        const selectionGroup = row[i];
                        if (subjectNameFromHeader && selectionGroup) {
                            const key = `${grade}_${subjectNameFromHeader}_${selectionGroup}`;
                            const infoList = electiveInfoMap[key];
                            if (infoList) {
                                infoList.forEach(info => {
                                    if (!info.times) return;
                                    const details = [];
                                    if (info.location) {
                                        details.push(`<span class="location-chip">${info.location}</span>`);
                                    }
                                    if (info.teacher) {
                                        details.push(`<span class="teacher-name">${info.teacher}</span>`);
                                    }

                                    const content = `
                                        <div class="subject-name">${info.subject}</div>
                                        <span class="elective-class-name" style="display:none;">${selectionGroup}</span>
                                        ${details.length > 0 ? `<div class="details">${details.join('<br>')}</div>` : ''}
                                    `;

                                    const timeParts = info.times.split(',').filter(t => t.trim());
                                    timeParts.forEach(part => {
                                        const dayMatch = part.match(/^[월화수목금]/);
                                        const periodMatch = part.match(/\d+$/);
                                        if (dayMatch && periodMatch) {
                                            const day = dayMatch[0];
                                            const periodIndex = parseInt(periodMatch[0], 10) - 1;
                                            if (student.schedule[day] && periodIndex >= 0 && periodIndex < student.maxPeriods) {
                                                student.schedule[day][periodIndex] = content;
                                            }
                                        }
                                    });
                                });
                            }
                        }
                    }

                    // 고정과목 배치
                    const fixedSchedule = fixedSchedules[student.homeroom];
                    if (fixedSchedule) {
                        daysInOrder.forEach(day => {
                            const dayIndex = daysInOrder.indexOf(day);
                            for (let i = 0; i < student.maxPeriods; i++) {
                                const subjectInfo = fixedSchedule.schedule[day]?.[i];
                                if (i < student.periodCounts[dayIndex] && !student.schedule[day][i] && subjectInfo) {
                                    const details = [];
                                    if (subjectInfo.teacher) {
                                        details.push(`<span class="teacher-name">${subjectInfo.teacher}</span>`);
                                    }
                                    if (subjectInfo.location) {
                                        details.push(`<span class="location-chip">${subjectInfo.location}</span>`);
                                    }
                                    student.schedule[day][i] = `
                                        <div class="subject-name">${subjectInfo.subject}</div>
                                        ${details.length > 0 ? `<div class="details">${details.join('<br>')}</div>` : ''}
                                    `;
                                }
                            }
                        });
                    }
                    students.push(student);
                });
            });
            return students;
        }

        function generateAndDownloadHtml() {
            if (!timetableData.weekly || timetableData.selection.length === 0 || !timetableData.info) {
                showToast("모든 파일이 올바르게 업로드되었는지 확인해주세요.", 'error');
                return;
            }

            updateStepIndicator(3);
            showLoading('시간표 HTML을 생성하고 있습니다...');

            // 잠시 대기 후 실행하여 로딩 UI가 먼저 표시되도록
            setTimeout(() => {
                waitForTemplate(() => {
                    generateHtmlAfterTemplateLoaded();
                });
            }, 100);
        }

        function generateHtmlAfterTemplateLoaded() {
            try {
                const studentsData = processAllData();
                if (studentsData.length === 0) {
                    hideLoading();
                    showToast("처리할 학생 데이터가 없습니다. 엑셀 파일 내용을 확인해주세요.", 'error');
                    return;
                }

                const selectedFeatures = {
                    student: document.getElementById('feature-student').checked,
                    class: document.getElementById('feature-class').checked,
                    classroom: document.getElementById('feature-classroom').checked,
                    teacher: document.getElementById('feature-teacher').checked
                };

                console.log('[GENERATE] Selected features:', selectedFeatures);

                const hasAnyFeature = Object.values(selectedFeatures).some(feature => feature);
                if (!hasAnyFeature) {
                    hideLoading();
                    showToast("최소 하나의 조회 기능을 선택해주세요.", 'warning');
                    return;
                }

                const pageTitle = document.getElementById('timetable-title').value.trim() || '시간표 조회 시스템';
                const dataString = JSON.stringify(studentsData);

                if (typeof window.StudentTimetableTemplate === 'undefined') {
                    hideLoading();
                    showToast('템플릿 파일이 제대로 로드되지 않았습니다. 페이지를 새로고침해주세요.', 'error');
                    console.error('[ERROR] StudentTimetableTemplate is not defined');
                    return;
                }

                if (typeof window.StudentTimetableTemplate.getHtmlTemplate !== 'function') {
                    hideLoading();
                    showToast('템플릿 함수가 올바르지 않습니다. student-timetable-template.js 파일을 확인해주세요.', 'error');
                    console.error('[ERROR] getHtmlTemplate function not found');
                    return;
                }

                const finalHtml = window.StudentTimetableTemplate.getHtmlTemplate(
                    dataString,
                    pageTitle,
                    timetableData.iconBase64,
                    timetableData.selectedTheme,
                    selectedFeatures,
                    timetableData.weekly,
                    timetableData.weeklyFormat
                );

                const blob = new Blob([finalHtml], { type: 'text/html;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'timetable_system.html';
                document.body.appendChild(link);
                link.click();
                URL.revokeObjectURL(link.href);
                document.body.removeChild(link);

                hideLoading();
                setStatus('최종 HTML 파일 다운로드가 완료되었습니다!', 'success');
                showToast('HTML 파일이 성공적으로 생성되었습니다!', 'success');
            } catch(e) {
                hideLoading();
                setStatus('오류 발생! ' + e.message + '. 개발자 도구(F12) 콘솔을 확인하세요.', 'error');
                console.error('[ERROR]', e);
            }
        }
    </script>

</body>
</html>
